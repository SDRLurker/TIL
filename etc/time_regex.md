참고주소 : [https://stackoverflow.com/questions/8318236/regex-pattern-for-hhmmss-time-string](https://stackoverflow.com/questions/8318236/regex-pattern-for-hhmmss-time-string)

# HH:MM:SS 시간 문자열에 대한 정규식 패턴

저는 `hh:mm:ss` 문자열을 파싱하고 싶습니다. 간단한 방법은 `2:3:24` 또는 `02:03:24` 문자열이 기대되는 `([0-1]?\d|2[0-3]):([0-5]?\d):([0-5]?\d)`입니다.

저는 더 단계를 진행하고 싶고 다음과 같은 경우에 유효성을 통과하는지 알고 싶습니다.

1. 56만 입력할 경우, 통과해야하며, 56은 56초 [SS]로 고려될 수 있습니다.
2. 2:3 또는 02:03 또는 02:3 또는 2:03을 입력해도 통과해야 합니다. 2분 3초 [MM:SS]의 의미입니다.
3. 20:30:12를 입력하면 20시 30분 12초 [HH:MM:SS]라는 의미로 통과합니다.
4. 78:12를 입력하면 78분은 틀렸기 때문에 통과할 수 없습니다.

기본적으로 ":"이 발견되면, ":" 앞에 숫자는 MM으로, ":" 뒤의 숫자는 SS로 간주합니다. 두 개의 ":"이 발견되면 HH:MM:SS로 갅주합니다.

전 이 패턴을 생각해 냈습니다.

```
(^([0-1]?\d|2[0-3]):([0-5]?\d):([0-5]?\d)$)|(^([0-5]?\d):([0-5]?\d)$)|(^[0-5]?\d$)
```

잘 작동하는 것 같습니다. 저는 이 작업을 할 수 있는 다른 더 간단한 정규식을 알고 싶습니다.

---

## 2개 답변 중 1개

```
^(?:(?:([01]?\d|2[0-3]):)?([0-5]?\d):)?([0-5]?\d)$
```

**설명:**

```
^                   # 문자열의 시작
(?:                 # 맞는가 시도...
 (?:                #  맞는가 시도...
  ([01]?\d|2[0-3]): #   HH:
 )?                 #  (옵션으로).
 ([0-5]?\d):        #  MM: (필수)
)?                  # (그룹 전체가 옵션, 그래서 HH:MM: 또는 MM: 또는 없음의 의미)
([0-5]?\d)          # SS (필수)
$                   # 문자열의 끝
```
